"""
恶意代码检测模块 - malfind、进程镂空检测、可疑进程检测等
"""

from typing import Optional, List
from core.loader import get_vmm


def register_malware_tools(mcp):
    """注册恶意代码检测相关工具"""
    
    @mcp.tool()
    def malfind(mempath: str, pid: Optional[int] = None) -> dict:
        """
        检测可疑内存页（代码注入检测）
        
        检测具有可执行权限但不是正常模块映射的内存区域，
        这些区域可能包含注入的 shellcode 或恶意代码。
        
        Args:
            mempath: 内存镜像文件路径
            pid: 进程 ID（可选，不指定则扫描所有进程）
        
        Returns:
            可疑内存区域列表
        """
        try:
            vmm = get_vmm(mempath)
            
            findings = []
            
            # 获取要扫描的进程列表
            if pid is not None:
                processes = [vmm.process(pid)]
            else:
                processes = vmm.process_list()
            
            for proc in processes:
                try:
                    if not proc.is_usermode:
                        continue
                    
                    maps = proc.maps
                    
                    # 分析 VAD
                    for vad in maps.vad():
                        try:
                            protection = str(vad.protection) if hasattr(vad, 'protection') else ""
                            vad_type = str(vad.type) if hasattr(vad, 'type') else ""
                            tag = str(vad.tag) if hasattr(vad, 'tag') else ""
                            info = str(vad.info) if hasattr(vad, 'info') else ""
                            
                            # 检测可疑条件
                            is_suspicious = False
                            reason = []
                            
                            # 1. RWX 权限（可读可写可执行）
                            if "EXECUTE" in protection.upper() and "WRITE" in protection.upper():
                                is_suspicious = True
                                reason.append("RWX 权限")
                            
                            # 2. 私有可执行内存（非文件映射）
                            if "EXECUTE" in protection.upper() and "Private" in vad_type and not info:
                                is_suspicious = True
                                reason.append("私有可执行内存（无文件映射）")
                            
                            # 3. PAGE_EXECUTE_READWRITE 保护
                            if "PAGE_EXECUTE_READWRITE" in protection:
                                is_suspicious = True
                                reason.append("PAGE_EXECUTE_READWRITE")
                            
                            if is_suspicious:
                                # 尝试读取内存开头检查是否有 PE 头
                                has_pe_header = False
                                header_hex = ""
                                try:
                                    header = proc.memory.read(vad.start, 64)
                                    header_hex = header[:32].hex()
                                    if header[:2] == b'MZ':
                                        has_pe_header = True
                                        reason.append("发现 MZ 头（可能是注入的 PE）")
                                except:
                                    pass
                                
                                findings.append({
                                    "pid": proc.pid,
                                    "process_name": proc.name,
                                    "vad_start": hex(vad.start),
                                    "vad_end": hex(vad.end),
                                    "size": vad.end - vad.start,
                                    "protection": protection,
                                    "type": vad_type,
                                    "tag": tag,
                                    "has_pe_header": has_pe_header,
                                    "header_hex": header_hex,
                                    "reasons": reason
                                })
                        except:
                            continue
                except:
                    continue
            
            # 按严重程度排序（有 PE 头的优先）
            findings.sort(key=lambda x: (not x.get("has_pe_header", False), x.get("pid", 0)))
            
            pe_count = len([f for f in findings if f.get("has_pe_header")])
            
            return {
                "success": True,
                "tool": "malfind",
                "summary": f"发现 {len(findings)} 个可疑内存区域，其中 {pe_count} 个包含 PE 头",
                "alerts": [
                    {"level": "high", "message": f"发现 {pe_count} 个可能的代码注入"}
                ] if pe_count > 0 else [],
                "data": findings
            }
        except Exception as e:
            return {
                "success": False,
                "tool": "malfind",
                "error": str(e)
            }
    
    @mcp.tool()
    def hollowfind(mempath: str) -> dict:
        """
        检测进程镂空（Process Hollowing）
        
        进程镂空是一种将恶意代码注入到合法进程的技术，
        通过替换进程的主模块内存来隐藏恶意代码。
        
        Args:
            mempath: 内存镜像文件路径
        
        Returns:
            可疑进程列表
        """
        try:
            vmm = get_vmm(mempath)
            
            suspicious = []
            
            for proc in vmm.process_list():
                try:
                    if not proc.is_usermode:
                        continue
                    
                    # 获取主模块
                    main_module = None
                    try:
                        for module in proc.module_list():
                            if module.name.lower() == proc.name.lower():
                                main_module = module
                                break
                            # 有时主模块名和进程名不完全匹配
                            if proc.name.lower().startswith(module.name.lower().replace('.exe', '')):
                                main_module = module
                                break
                    except:
                        continue
                    
                    if main_module is None:
                        suspicious.append({
                            "pid": proc.pid,
                            "name": proc.name,
                            "reason": "无法找到主模块",
                            "severity": "medium"
                        })
                        continue
                    
                    # 检查主模块内存
                    try:
                        # 读取主模块开头
                        header = proc.memory.read(main_module.base, 256)
                        
                        # 检查 DOS 头
                        if header[:2] != b'MZ':
                            suspicious.append({
                                "pid": proc.pid,
                                "name": proc.name,
                                "module_base": hex(main_module.base),
                                "reason": "主模块没有 MZ 头（可能被替换）",
                                "severity": "high"
                            })
                            continue
                        
                        # 检查 PE 头
                        e_lfanew = int.from_bytes(header[0x3C:0x40], 'little')
                        if e_lfanew > 0 and e_lfanew < 256:
                            if header[e_lfanew:e_lfanew+2] != b'PE':
                                suspicious.append({
                                    "pid": proc.pid,
                                    "name": proc.name,
                                    "module_base": hex(main_module.base),
                                    "reason": "PE 签名无效（可能被替换）",
                                    "severity": "high"
                                })
                    except:
                        pass
                    
                    # 检查路径异常
                    try:
                        if proc.pathuser:
                            path_lower = proc.pathuser.lower()
                            # 系统进程应该在 system32
                            system_procs = ['svchost.exe', 'lsass.exe', 'services.exe', 'csrss.exe', 'smss.exe']
                            if proc.name.lower() in system_procs:
                                if 'system32' not in path_lower and 'syswow64' not in path_lower:
                                    suspicious.append({
                                        "pid": proc.pid,
                                        "name": proc.name,
                                        "path": proc.pathuser,
                                        "reason": "系统进程运行在非标准路径",
                                        "severity": "high"
                                    })
                    except:
                        pass
                except:
                    continue
            
            high_count = len([s for s in suspicious if s.get("severity") == "high"])
            
            return {
                "success": True,
                "tool": "hollowfind",
                "summary": f"发现 {len(suspicious)} 个可疑进程，{high_count} 个高危",
                "data": suspicious
            }
        except Exception as e:
            return {
                "success": False,
                "tool": "hollowfind",
                "error": str(e)
            }
    
    @mcp.tool()
    def suspicious_processes(mempath: str) -> dict:
        """
        综合检测可疑进程
        
        检测多种可疑行为：
        - 异常父子关系
        - 可疑路径
        - 伪装进程名
        - 异常进程属性
        
        Args:
            mempath: 内存镜像文件路径
        
        Returns:
            可疑进程分析结果
        """
        try:
            vmm = get_vmm(mempath)
            
            suspicious = []
            
            # 构建进程字典
            proc_dict = {}
            for proc in vmm.process_list():
                try:
                    proc_dict[proc.pid] = {
                        "pid": proc.pid,
                        "ppid": proc.ppid,
                        "name": proc.name,
                        "path": proc.pathuser if hasattr(proc, 'pathuser') else "",
                        "cmdline": proc.cmdline if hasattr(proc, 'cmdline') else ""
                    }
                except:
                    continue
            
            for pid, proc in proc_dict.items():
                reasons = []
                severity = "low"
                
                name_lower = proc["name"].lower()
                path_lower = proc.get("path", "").lower()
                cmdline_lower = proc.get("cmdline", "").lower()
                
                # 1. 检查可疑路径
                suspicious_paths = ["temp", "tmp", "appdata\\local\\temp", "users\\public", "recycle"]
                if any(sp in path_lower for sp in suspicious_paths):
                    reasons.append("从临时/可疑目录运行")
                    severity = "medium"
                
                # 2. 检查进程名伪装
                # 正常系统进程拼写
                legitimate_names = {
                    "svchost.exe": "c:\\windows\\system32\\svchost.exe",
                    "lsass.exe": "c:\\windows\\system32\\lsass.exe",
                    "csrss.exe": "c:\\windows\\system32\\csrss.exe",
                    "services.exe": "c:\\windows\\system32\\services.exe",
                    "smss.exe": "c:\\windows\\system32\\smss.exe",
                    "explorer.exe": "c:\\windows\\explorer.exe",
                    "winlogon.exe": "c:\\windows\\system32\\winlogon.exe"
                }
                
                # 检查是否是伪装的系统进程
                for legit_name, legit_path in legitimate_names.items():
                    if name_lower == legit_name:
                        if path_lower and legit_path not in path_lower:
                            reasons.append(f"伪装系统进程 - 路径异常（应为 {legit_path}）")
                            severity = "high"
                
                # 检查类似名称的进程（拼写变体）
                similar_names = [
                    ("scvhost.exe", "svchost.exe"),
                    ("svch0st.exe", "svchost.exe"),
                    ("lsas.exe", "lsass.exe"),
                    ("1sass.exe", "lsass.exe"),
                    ("csrs.exe", "csrss.exe"),
                    ("explore.exe", "explorer.exe"),
                    ("exp1orer.exe", "explorer.exe"),
                ]
                for fake, real in similar_names:
                    if name_lower == fake:
                        reasons.append(f"可疑进程名（可能伪装 {real}）")
                        severity = "high"
                
                # 3. 检查异常父子关系
                ppid = proc["ppid"]
                if ppid in proc_dict:
                    parent_name = proc_dict[ppid]["name"].lower()
                    
                    # cmd/powershell 的异常父进程
                    if name_lower in ["cmd.exe", "powershell.exe"]:
                        suspicious_parents = ["winword.exe", "excel.exe", "outlook.exe", "powerpnt.exe"]
                        if parent_name in suspicious_parents:
                            reasons.append(f"Office 应用启动命令行（父进程: {parent_name}）")
                            severity = "high"
                    
                    # svchost 必须由 services.exe 启动
                    if name_lower == "svchost.exe" and parent_name != "services.exe":
                        reasons.append(f"svchost.exe 父进程异常（应为 services.exe，实际: {parent_name}）")
                        severity = "high"
                
                # 4. 检查可疑命令行
                suspicious_cmds = [
                    ("-nop", "NoProfile PowerShell"),
                    ("-w hidden", "隐藏窗口"),
                    ("-enc", "编码命令"),
                    ("downloadstring", "远程下载执行"),
                    ("invoke-expression", "动态执行"),
                    ("bypass", "绑过策略"),
                    ("vssadmin delete", "删除卷影"),
                    ("wmic shadowcopy", "卷影操作"),
                    ("certutil -urlcache", "Certutil 下载"),
                    ("bitsadmin /transfer", "BITS 下载"),
                ]
                for pattern, desc in suspicious_cmds:
                    if pattern in cmdline_lower:
                        reasons.append(f"可疑命令行: {desc}")
                        severity = "high"
                
                if reasons:
                    suspicious.append({
                        "pid": pid,
                        "name": proc["name"],
                        "ppid": proc["ppid"],
                        "path": proc.get("path", ""),
                        "cmdline": proc.get("cmdline", "")[:200],  # 截断长命令行
                        "reasons": reasons,
                        "severity": severity
                    })
            
            # 按严重程度排序
            severity_order = {"high": 0, "medium": 1, "low": 2}
            suspicious.sort(key=lambda x: severity_order.get(x.get("severity", "low"), 3))
            
            high_count = len([s for s in suspicious if s.get("severity") == "high"])
            medium_count = len([s for s in suspicious if s.get("severity") == "medium"])
            
            return {
                "success": True,
                "tool": "suspicious_processes",
                "summary": f"发现 {len(suspicious)} 个可疑进程（高危: {high_count}, 中危: {medium_count}）",
                "alerts": [
                    {"level": "high", "message": f"{high_count} 个进程存在高危特征"}
                ] if high_count > 0 else [],
                "data": suspicious
            }
        except Exception as e:
            return {
                "success": False,
                "tool": "suspicious_processes",
                "error": str(e)
            }
